/**
 * Tier 3: .htaccess generator
 * Generates a valid Apache .htaccess file with redirect rules, cache control, and compression.
 *
 * Checklist 2-D:
 * - Output validation: Apache directive syntax check
 * - Injection prevention: RewriteRule pattern metacharacter validation
 * - No browser-dependent APIs
 */
const MAX_REDIRECT_RULES = 100;
const MAX_PATH_LENGTH = 2048;
const VALID_STATUS_CODES = [301, 302, 307, 308];
/**
 * Dangerous patterns in RewriteRule paths that could indicate injection.
 * Blocks: backticks, $(command), %{ENV:...} tricks, newlines.
 */
const DANGEROUS_PATTERNS = [
    /`/, // backtick command execution
    /\$\(/, // $(command) substitution
    /\$\{/, // ${var} substitution
    /%\{/, // %{ENV:VAR} server variable injection
    /[\n\r]/, // newline injection
    /\x00/, // null byte
];
/**
 * Validate a path for use in RewriteRule — reject injection attempts.
 */
function isPathSafe(path) {
    for (const pattern of DANGEROUS_PATTERNS) {
        if (pattern.test(path)) {
            return { safe: false, reason: `contains potentially dangerous pattern: ${pattern.source}` };
        }
    }
    return { safe: true };
}
/**
 * Validate redirect status code.
 */
function isValidStatusCode(code) {
    return VALID_STATUS_CODES.includes(code);
}
/**
 * Validate and escape file extension for Apache FilesMatch.
 * Only allows alphanumeric, dot, hyphen — rejects path-like values.
 */
function escapeExtension(ext) {
    if (!/^[a-zA-Z0-9._-]+$/.test(ext)) {
        return { escaped: "", valid: false };
    }
    return { escaped: ext.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), valid: true };
}
/**
 * Map HTTP status code to Apache redirect flag.
 */
function statusToFlag(code) {
    switch (code) {
        case 301: return "R=301,L";
        case 302: return "R=302,L";
        case 307: return "R=307,L";
        case 308: return "R=308,L";
        default: return "R=301,L";
    }
}
export function handleGenerateHtaccess(input) {
    const issues = [];
    const sections = [];
    const redirectRules = input.redirectRules ?? [];
    const cacheControl = input.cacheControl ?? [];
    // Runtime validation (checklist 2-A)
    if (redirectRules.length > MAX_REDIRECT_RULES) {
        throw new Error(`redirectRules exceeds maximum of ${MAX_REDIRECT_RULES} items (received ${redirectRules.length})`);
    }
    sections.push("# .htaccess generated by ZERONOVA LAB MCP Server");
    // Force HTTPS
    if (input.forceHttps) {
        sections.push("");
        sections.push("# Force HTTPS");
        sections.push("RewriteEngine On");
        sections.push("RewriteCond %{HTTPS} off");
        sections.push("RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]");
    }
    // Remove trailing slash
    if (input.removeTrailingSlash) {
        sections.push("");
        sections.push("# Remove trailing slash");
        if (!input.forceHttps) {
            sections.push("RewriteEngine On");
        }
        sections.push("RewriteCond %{REQUEST_FILENAME} !-d");
        sections.push("RewriteRule ^(.*)/$ /$1 [R=301,L]");
    }
    // Redirect rules
    if (redirectRules.length > 0) {
        sections.push("");
        sections.push("# Redirect rules");
        if (!input.forceHttps && !input.removeTrailingSlash) {
            sections.push("RewriteEngine On");
        }
        for (let i = 0; i < redirectRules.length; i++) {
            const rule = redirectRules[i];
            if (!rule.from || typeof rule.from !== "string") {
                issues.push(`Rule ${i}: missing or invalid 'from' path`);
                continue;
            }
            if (!rule.to || typeof rule.to !== "string") {
                issues.push(`Rule ${i}: missing or invalid 'to' path`);
                continue;
            }
            if (rule.from.length > MAX_PATH_LENGTH || rule.to.length > MAX_PATH_LENGTH) {
                issues.push(`Rule ${i}: path exceeds maximum ${MAX_PATH_LENGTH} characters`);
                continue;
            }
            // Injection prevention (checklist 2-D)
            const fromCheck = isPathSafe(rule.from);
            if (!fromCheck.safe) {
                issues.push(`Rule ${i}: 'from' path ${fromCheck.reason}`);
                continue;
            }
            const toCheck = isPathSafe(rule.to);
            if (!toCheck.safe) {
                issues.push(`Rule ${i}: 'to' path ${toCheck.reason}`);
                continue;
            }
            const statusCode = rule.statusCode ?? 301;
            if (!isValidStatusCode(statusCode)) {
                issues.push(`Rule ${i}: invalid statusCode ${statusCode} (must be 301, 302, 307, or 308)`);
                continue;
            }
            // Normalize 'from' path: strip leading slash for RewriteRule pattern
            const fromPattern = rule.from.startsWith("/")
                ? `^${rule.from.slice(1)}$`
                : `^${rule.from}$`;
            sections.push(`RewriteRule ${fromPattern} ${rule.to} [${statusToFlag(statusCode)}]`);
        }
    }
    // gzip compression
    if (input.compressionEnabled) {
        sections.push("");
        sections.push("# Enable gzip compression");
        sections.push("<IfModule mod_deflate.c>");
        sections.push("  AddOutputFilterByType DEFLATE text/html");
        sections.push("  AddOutputFilterByType DEFLATE text/css");
        sections.push("  AddOutputFilterByType DEFLATE text/javascript");
        sections.push("  AddOutputFilterByType DEFLATE application/javascript");
        sections.push("  AddOutputFilterByType DEFLATE application/json");
        sections.push("  AddOutputFilterByType DEFLATE application/xml");
        sections.push("  AddOutputFilterByType DEFLATE image/svg+xml");
        sections.push("</IfModule>");
    }
    // Cache control
    if (cacheControl.length > 0) {
        sections.push("");
        sections.push("# Cache control");
        sections.push("<IfModule mod_expires.c>");
        sections.push("  ExpiresActive On");
        for (const rule of cacheControl) {
            if (!rule.extension || typeof rule.extension !== "string") {
                issues.push(`Cache rule: missing or invalid extension`);
                continue;
            }
            if (typeof rule.maxAge !== "number" || rule.maxAge < 0 || rule.maxAge > 31536000) {
                issues.push(`Cache rule for .${rule.extension}: maxAge must be 0-31536000 seconds`);
                continue;
            }
            const extResult = escapeExtension(rule.extension);
            if (!extResult.valid) {
                issues.push(`Cache rule: invalid extension "${rule.extension}" (only alphanumeric, dot, hyphen allowed)`);
                continue;
            }
            sections.push(`  <FilesMatch "\\.${extResult.escaped}$">`);
            sections.push(`    ExpiresDefault "access plus ${rule.maxAge} seconds"`);
            sections.push("  </FilesMatch>");
        }
        sections.push("</IfModule>");
    }
    sections.push("");
    const content = sections.join("\n");
    const lineCount = content.split("\n").length;
    // Output validation: check for obviously malformed directives
    const hasRewriteEngine = content.includes("RewriteEngine On");
    const hasRewriteRule = content.includes("RewriteRule");
    if (hasRewriteRule && !hasRewriteEngine) {
        issues.push("RewriteRule found without RewriteEngine On");
    }
    return {
        content,
        lineCount,
        validation: {
            isValid: issues.length === 0,
            issues,
        },
    };
}
//# sourceMappingURL=htaccess-generator.js.map